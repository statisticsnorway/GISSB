usethis::use_r("adresse_api_koord")
usethis::use_test()
usethis::use_test("adresse_api_koord")
load_all()
usethis::load_all()
devtools::load_all()
usethis::test_that("multiplication works",
{
fra <- adresse_api_koord(postnummer = "0177",
adresse = "Akersveien 26")
})
test_that("multiplication works",
{
fra <- adresse_api_koord(postnummer = "0177",
adresse = "Akersveien 26")
})
check()
library(usethis)
check()
library(roxygen2)
check()
library(testthat)
check()
check()
devtools::check()
devtools::load_all()
fra <- adresse_api_koord(postnummer = "0177",
adresse = "Akersveien 26")
testthat::test_that("multiplication works",
{
fra <- adresse_api_koord(postnummer = "0177",
adresse = "Akersveien 26")
})
testthat::test_that(adresse_api_koord(postnummer = "0177", adresse = "Akersveien 26"))
use_mit_license()
use_mit_license()
document()
library(devtools)
library(usethis)
library(roxygen2)
library(testthat)
document()
roxygen2::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
install()
adresse_api_koord
curl::has_internet()
!is.null(nslookup("https://ws.geonorge.no/adresser/v1/", error = FALSE))
!is.null(curl::nslookup("https://ws.geonorge.no/adresser/v1/", error = FALSE))
!is.null(curl::nslookup("www.'ws.geonorge.no/adresser/v1/", error = FALSE))
!is.null(curl::nslookup("www.ws.geonorge.no/adresser/v1/", error = FALSE))
if (is.character(RCurl::getURL("https://ws.geonorge.no/adresser/v1/"))) {
out <- TRUE
} else {
out <- FALSE
}
if (is.character(RCurl::getURL("https://ws.geonorge.no/adresser/v1/"))) {
out <- TRUE
} else {
out <- FALSE
}
out <-try(is.character(RCurl::getURL("https://ws.geonorge.no/adresser/v1/"))) == TRUE
out <-try(is.character(RCurl::getURL("https://ws.geonorge.no/adresser/v1/"))) == TRUE
out <-try(is.character(RCurl::getURL("https://ws.geonorge.no/adresser/v1/"))) == TRUE
print("ooops")
print("Mangler tilgang til https://ws.geonorge.no/adresser/v1/")
if (try(is.character(RCurl::getURL("https://ws.geonorge.no/adresser/v1/"))) == TRUE) == FALSE) {
print("Mangler tilgang til https://ws.geonorge.no/adresser/v1/")
}
if ((try(is.character(RCurl::getURL("https://ws.geonorge.no/adresser/v1/"))) == TRUE) == FALSE) {
print("Mangler tilgang til https://ws.geonorge.no/adresser/v1/")
}
#' Adresser til koordinater
#'
#' Funksjon for å finne koordinater fra matrikkelen (adresse-API fra Kartverket).
#'
#' @param postnummer Karaktervektor med postnummer
#' @param adresse Karaktervektor med gateadresse (med gatenummer hvis tilgjengelig)
#' @param format Format på datasettet som returneres. Default er satt til "sf" (sf-objekt), men det er også mulig å sette format = "tibble" eller "data.frame"
#' @param crs Numerisk vektor med ønsket koordinatsystem for koordinatene. Default er satt til CRS 25833.
#'
#' @returns Objekt med koordinatene til adressene.
#' @export
#'
#' @examples
#' fra <- adresse_api_koord(postnummer = "0177",
#'                         adresse = "Akersveien 26")
#' @encoding UTF-8
#'
#'
adresse_api_koord <- function(postnummer,
adresse,
format = "sf",
crs = 25833) {
if ((try(is.character(RCurl::getURL("https://ws.geonorge.no/adresser/v1/"))) == TRUE) == FALSE) {
print("Mangler tilgang til https://ws.geonorge.no/adresser/v1/")
stop()
}
# Laster inn pakker #
suppressWarnings(
suppressPackageStartupMessages({
library(tidyverse)
library(httr)
library(sf)
}))
# Funksjon for å hente lat og lon til gitt adresse #
adresse_koord_funk <- function(postnummer, adresse){
resp <- httr::GET(paste0("https://ws.geonorge.no/adresser/v1/sok?",
"postnummer=", postnummer, "&",
"adressetekst=", "'", gsub(" ", "+", adresse), "'"))
cont_raw <- httr::content(resp)
if (cont_raw$metadata$totaltAntallTreff == 1) {
lat <- cont_raw$adresser[[1]]$representasjonspunkt$lat
lon <- cont_raw$adresser[[1]]$representasjonspunkt$lon
kommunenummer <- cont_raw$adresser[[1]]$kommunenummer
kommunenavn <- cont_raw$adresser[[1]]$kommunenavn
} else {
lat <- NA
lon <- NA
kommunenummer <- NA
kommunenavn <- NA
kommunenavn <- NA
}
adresse_koord <- data.frame(adresse, postnummer, lon, lat, kommunenummer, kommunenavn)
return(adresse_koord_alle <- rbind(adresse_koord_alle, adresse_koord))
}
# Vektoriserer funksjon adresse_koord_funk #
adresse_koord_funk_vec <- Vectorize(adresse_koord_funk, vectorize.args = c("postnummer", "adresse"))
# Bruker vektorene i funksjonen for å finne koordinatene til hver adresse #
adresse_koord_alle <- data.frame()
adresser_koord <- adresse_koord_funk_vec(postnummer, adresse)
# Gjør om til data frame #
adresser_koord <- as.data.frame(t(adresser_koord))
adresser_koord[] <- lapply(adresser_koord, unlist)
adresser_koord$ID <- rep(1:nrow(adresser_koord))
# Identifiserer adresser som mangler koordinater #
adresser_koord_missing <- adresser_koord %>%
dplyr::filter(is.na(lat))
if (format == "sf" & nrow(adresser_koord_missing)==0) {
adresser_koord <- adresser_koord %>%
sf::st_as_sf(coords = c("lon", "lat"), crs = 4258) %>%
sf::st_transform(crs = crs)
}
if (format == "tibble") {
adresser_koord <- adresser_koord %>%
as_tibble()
}
return(adresser_koord)
}
fra <- adresse_api_koord(postnummer = "0177",
adresse = "Akersveien 26")
?GISSB
??GISSB
library(GISSB)
?GISSB
install()
?GISSB
use_package()
use_package("tidyverse")
use_package("dplyr")
use_package(c("dplyr", "httr", "sf"))
use_package("dplyr", "httr", "sf")
use_package
use_package(c("dplyr", "httr", "sf"), type = "imports"
use_package(c("dplyr", "httr", "sf"), type = "imports")
use_package(c("dplyr", "httr", "sf"), type = "imports")
use_package("dplyr", type = "imports")
use_package("dplyr", type = "imports")
use_package("httr", type = "imports")
use_package("sf", type = "imports")
use_readme_rmd()
build_readme()
usethis::use_r("koords_to_google")
# Forenkler koordinatene for å klippe og lime inn i Google Maps #
koords_4326 <- sf::st_transform(koords, crs = 4326) %>%
dplyr::mutate(coords_google_1 = gsub("^(.*?),.*", "\\1", as.character(geometry)),
coords_google_2 = gsub(".*,", "\\1", as.character(geometry))) %>%
dplyr::mutate(coords_google_1 = gsub("^c\\(|\\)$", "", as.character(coords_google_1)),
coords_google_2 = gsub(").*", "", coords_google_2)) %>%
dplyr::mutate(coords_google_1 = as.numeric(str_trim(coords_google_1)),
coords_google_2 = as.numeric(str_trim(coords_google_2))) %>%
dplyr::mutate(coords_google = paste0(coords_google_2, ", ", coords_google_1)) %>%
dplyr::select(-coords_google_1, -coords_google_2) %>%
sf::st_transform(koords, crs = crs_out)
usethis::use_test("koords_to_google")
devtools::document()
devtools::load_all()
devtools::load_all()
usethis::use_r("beregne_avstand_cpp")
beregne_avstand_cpp <- function(from_node_ID,
to_node_ID,
enhet = "FT_MINUTES",
from_ID,
to_ID,
dist = "all") {
if (enhet == "FT_MINUTES") {
graph_cppRouting <- graph_cppRouting_FT_MINUTES
}
if (enhet == "LENGTH") {
graph_cppRouting <- graph_cppRouting_LENGTH
}
dists <- cppRouting::get_distance_matrix(graph_cppRouting,
from = from_node_ID,
to = to_node_ID,
algorithm = "phast")
dists2 <- data.frame(dists)
dists2 <- tibble::rownames_to_column(dists2, "from_node")
dists2_long <- reshape2::melt(dists2, id.vars = "from_node",
variable.name = "to_node",
value.name = "length")
dists2_long$to_node <- gsub("X", "", dists2_long$to_node)
# # OBS?
# to_node <- to_node %>%
#   dplyr::rename(to_node = nodeID) %>%
#   dplyr::mutate(to_node = as.character(to_node))
#
# # OBS?
# from_node <- from_node %>%
#   dplyr::rename(from_node = nodeID) %>%
#   dplyr::mutate(from_node = as.character(from_node))
# to_node <- to_node %>%
#   dplyr::select(!!as.name(to_ID), to_node)  # avstand_koord_node, geometry?
# dists2_long <- dists2_long %>%
#   dplyr::left_join(to_node, by = "to_node") # %>% # Legger til navn på fødeavdelingene
#   # dplyr::select(-membership)
# from_node <- from_node %>%
#   dplyr::select(!!as.name(from_ID), from_node)
if (dist == "min") {
# Beholder kun den nærmeste fødeavdelingen #
dists2_long <- dists2_long %>%
dplyr::group_by(from_node) %>%
# dplyr::slice(which.min(minutter)) %>%
dplyr::slice(which.min(length)) # %>% #OBS?
# dplyr::right_join(from_node, by = c("from_node"))
}
if (dist == "max") {
# Beholder kun fødeavdelingen som er lengst unna #
dists2_long <- dists2_long %>%
dplyr::group_by(from_node) %>%
# dplyr::slice(which.min(minutter)) %>%
dplyr::slice(which.max(length)) # %>% #OBS?
# dplyr::right_join(from_node, by = c("from_node"))
}
dists2_long$from_node <- as.integer(dists2_long$from_node)
dists2_long$to_node <- as.integer(dists2_long$to_node)
return(dists2_long)
}
usethis::use_test("beregne_avstand_cpp")
devtools::load_all()
library(dplyr)
# Laster inn vegnett
vegnett <- arrow::open_dataset("X:/330/Helse-Individ-gruppe/2020-PA8-S-E-GEOS -WP2/GIS i R/Data/Vegnettverk/vegnett2021.parquet") %>%
dplyr::filter(FYLKE_ID %in% c("3", "2", "4")) %>% # OBSOBSOBS
sfarrow::read_sf_dataset()
vegnett_list <- vegnett_to_R(vegnett = vegnett)
graph <- vegnett_list[[1]]
avstand_cpp_min <- beregne_avstand_cpp(26956,
210373,
enhet = "FT_MINUTES")
avstand_cpp_min
graph_cppRouting_FT_MINUTES <- vegnett_list[[4]]
graph_cppRouting_LENGTH <- vegnett_list[[5]]
vegnett_list
graph_cppRouting_FT_MINUTES <- vegnett_list[[4]]
graph_cppRouting_LENGTH <- vegnett_list[[5]]
avstand_cpp_min <- beregne_avstand_cpp(26956,
210373,
enhet = "FT_MINUTES")
avstand_cpp_min
class(avstand_cpp_min)
testthat::test_that("Tester beregne_avstand", {
avstand_cpp_min <- beregne_avstand_cpp(26956,
210373,
enhet = "FT_MINUTES")
expect_type(avstand_cpp_min, "data.frame")
avstand_cpp_meter <- beregne_avstand_cpp(26956,
210373,
enhet = "LENGTH")
expect_type(avstand_cpp_meter, "data.frame")
})
avstand_cpp_min
class(avstand_cpp_min)
avstand_cpp_min
testthat::test_that("Tester beregne_avstand", {
avstand_cpp_min <- beregne_avstand_cpp(26956,
210373,
enhet = "FT_MINUTES")
expect_type(avstand_cpp_min, "list")
avstand_cpp_meter <- beregne_avstand_cpp(26956,
210373,
enhet = "LENGTH")
expect_type(avstand_cpp_meter, "list")
})
testthat::test_that("Tester beregne_avstand", {
avstand_cpp_min <- beregne_avstand_cpp(26957,
210373,
enhet = "FT_MINUTES")
expect_type(avstand_cpp_min, "list")
avstand_cpp_meter <- beregne_avstand_cpp(26956,
210373,
enhet = "LENGTH")
expect_type(avstand_cpp_meter, "list")
})
testthat::test_that("Tester beregne_avstand", {
avstand_cpp_min <- beregne_avstand_cpp(123,
210373,
enhet = "FT_MINUTES")
expect_type(avstand_cpp_min, "list")
avstand_cpp_meter <- beregne_avstand_cpp(26956,
210373,
enhet = "LENGTH")
expect_type(avstand_cpp_meter, "list")
})
avstand_cpp_min
avstand_cpp_min <- beregne_avstand_cpp(26956,
210373,
enhet = "FT_MINUTES")
avstand_cpp_min
avstand_cpp_min <- beregne_avstand_cpp(123,
210373,
enhet = "FT_MINUTES")
avstand_cpp_min
avstand_cpp_min <- beregne_avstand_cpp(1,
210373,
enhet = "FT_MINUTES")
avstand_cpp_min
avstand_cpp_min <- beregne_avstand_cpp(123123123,
210373,
enhet = "FT_MINUTES")
testthat::test_that("Tester beregne_avstand", {
avstand_cpp_min <- beregne_avstand_cpp(123123123,
210373,
enhet = "FT_MINUTES")
expect_type(avstand_cpp_min, "list")
avstand_cpp_meter <- beregne_avstand_cpp(26956,
210373,
enhet = "LENGTH")
expect_type(avstand_cpp_meter, "list")
})
avstand_cpp_min <- beregne_avstand_cpp(c(26956, 26956),
210373,
enhet = "FT_MINUTES")
avstand_cpp_min <- beregne_avstand_cpp(c(26956, 26955),
210373,
enhet = "FT_MINUTES")
avstand_cpp_min
View(avstand_cpp_min)
# rm(list = c("vegnett_to_R"))
devtools::document()
rm(list = c("vegnett_to_R"))
devtools::document()
rm(list = c("beregne_avstand_cpp"))
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
usethis::use_package("purrr", type = "imports")
usethis::use_package("tibble", type = "imports")
usethis::use_package("leaflet", type = "imports")
graph
path <- beregne_avstand(from_node = 26956,
to_node = 210373,
enhet = "FT_MINUTES",
path = T)
path
class(path)
usethis::use_r("path_leaflet")
usethis::use_test("path_leaflet")
path_leaflet(path)
#' Visualisere kjørerute med Leaflet
#'
#' Funksjonen path_leaflet visualiserer den korteste kjøreruten (i minutter eller meter) som har blitt beregnet med funksjonen beregne_avstand (der path = TRUE).
#'
#' @param path Objekt (list) som har blitt laget med funksjonen beregne_avstand (der path = TRUE).
#'
#' @returns Interaktivt kart Leaflet som viser kjøreruten mellom et valgt fra- og tilpunkt på vegnettet.
#' @export
#'
#' @examples
#' path_leaflet(path)
#' @encoding UTF-8
#'
#'
path_leaflet <- function(path) {
path_graph_length <- graph %>%
igraph::subgraph.edges(eids = path$epath %>%
unlist()) %>%
tidygraph::as_tbl_graph()
leaflet_out <- path_graph_length %>%
tidygraph::activate(edges) %>%
tibble::as_tibble() %>%
sf::st_as_sf() %>%
sf::st_transform(4326) %>%
leaflet::leaflet() %>%
leaflet::addPolylines() %>%
leaflet::addTiles()
return(leaflet_out)
}
path_leaflet(path)
map <- path_leaflet(path)
class(map)
test_that("Tester path_leaflet", {
map <- path_leaflet(path)
expect_type(avstand_cpp_meter, "leaflet")
})
test_that("Tester path_leaflet", {
map <- path_leaflet(path)
expect_type(map, "leaflet")
})
expect_type(map, "list")
test_that("Tester path_leaflet", {
map <- path_leaflet(path)
expect_type(map, "list")
})
