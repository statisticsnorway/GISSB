sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(from_coord) <- c("X", "Y")
node_index_o <- nabor::knn(data = coords_start,
query = from_coord,
k = knn)
nodes_start <- sf::st_transform(nodes_start, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(from_node = nodeID,
coords_google_from_node = coords_google) %>%
dplyr::select(-geometry)
start_node <- nodes_start[node_index_o$nn.idx, ]
start_node$knn <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
select(-geometry)
dists <-  data.frame(ID, node_index_o$nn.dists)
# return(dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_from") %>%
dplyr::select(-variabel)
start_node <- cbind(start_node, dists)
return(start_node)
}
if (direction == "to"){
nodes_end <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$to))
if (membership == T){
nodes_end <- nodes_end %>%
dplyr::filter(membership %in% unique(from_node$membership))
}
coords_end <- nodes_end %>%
sf::st_coordinates()
to_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(to_coord) <- c("X", "Y")
node_index_d <- nabor::knn(data = coords_end,
query = to_coord,
k = 1)
nodes_end <- sf::st_transform(nodes_end, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(to_node = nodeID,
coords_google_to_node = coords_google) %>%
dplyr::select(-geometry)
end_node <- nodes_end[node_index_d$nn.idx, ]
end_node$knn <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
select(-geometry)
dists <-  data.frame(ID, node_index_d$nn.dists)
# return(dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_to") %>%
dplyr::select(-variabel)
end_node <- cbind(end_node, dists)
return(end_node)
}
}
from <- address_to_coord(zip_code = "0177",
address = "Akersveien 26")
from <- address_to_coords(zip_code = "0177",
address = "Akersveien 26")
from_node <- coords_to_node(coords = from, direction = "from")
vegnett <- arrow::open_dataset("X:/330/Helse-Individ-gruppe/2020-PA8-S-E-GEOS -WP2/GIS i R/Data/Vegnettverk/vegnett2021.parquet") %>%
dplyr::filter(FYLKE_ID %in% c("3", "2", "4")) %>%
sfarrow::read_sf_dataset()
# install.packages("C:/Users/rdn/Documents/GitHub/GISSB_0.1.0.tar.gz", repos = NULL, type="source")
# library(GISSB)
library(tidyverse)
# Laster inn vegnett
ds <- arrow::open_dataset("C:/Users/rdn/Documents/Kart/vegnett2021.parquet")
vegnett <- ds %>%
dplyr::filter(FYLKE_ID %in% c("3", "2", "4")) %>%
sfarrow::read_sf_dataset()
vegnett_list <- GISSB::vegnett_to_R(vegnett)
graph <- vegnett_list[[1]]
nodes <- vegnett_list[[2]]
edges <- vegnett_list[[3]]
graph_cppRouting_FT_MINUTES <- vegnett_list[[4]]
graph_cppRouting_LENGTH <- vegnett_list[[5]]
from_node <- coords_to_node(coords = from, direction = "from")
#' Convert coordinates to Google Maps
#'
#' Function to convert coordinates of an sf object to a format that is easy to copy and paste into Google Maps.
#'
#' @param coords An sf object with a geometry column that will be converted to CRS 4326.
#' @param crs_out Chosen coordinate reference system (CRS) for the geometry column of the returned sf object.
#' @returns An sf object with a new column added (coords_google), and an addtional sf geometry column with the chosen CRS.
#' @export
#'
#' @examples
#' \dontrun{
#' from <- address_to_coords(zip_code = "0177",
#'                          address = "Akersveien 26") %>%
#'   coords_to_google()
#'   }
#'
#' @encoding UTF-8
#'
#'
coords_to_google <- function(coords,
crs_out = 25833) {
# Forenkler koordinatene for å klippe og lime inn i Google Maps #
coords_4326 <- sf::st_transform(coords, crs = 4326) %>%
dplyr::mutate(coords_google_1 = gsub("^(.*?),.*", "\\1", as.character(geometry)),
coords_google_2 = gsub(".*,", "\\1", as.character(geometry))) %>%
dplyr::mutate(coords_google_1 = gsub("^c\\(|\\)$", "", as.character(coords_google_1)),
coords_google_2 = gsub(").*", "", coords_google_2)) %>%
dplyr::mutate(coords_google_1 = as.numeric(str_trim(coords_google_1)),
coords_google_2 = as.numeric(str_trim(coords_google_2))) %>%
dplyr::mutate(coords_google = paste0(coords_google_2, ", ", coords_google_1)) %>%
dplyr::select(-coords_google_1, -coords_google_2) %>%
sf::st_transform(coords, crs = crs_out)
# data.frame()
return(coords_4326)
}
from_node <- coords_to_node(coords = from, direction = "from")
from_node
#' Connect coordinates to the nearest nodes in the Norwegian road network
#'
#' Function to find the nearest nodes in the Norwegian road network for chosen coordinates.
#'
#' Before the function can be used, the nodes of the road network must be converted to an sf object that is called `nodes`. This can be done with the function `vegnett_to_R`.
#'
#' @param coords An sf object with the coordinates that should be connected to the road network.
#' @param direction Character vector with “from” if the points should be from nodes or “to” if the points should be to nodes.
#' @param ID_col Character vector with the name of the ID column. Default value is set to “ID”.
#' @param crs_out Numeric vector for the chosen coordinate reference system (CRS).
#' @param knn Numeric vector with the chosen number of nodes that should be returned for each of the coordinates. If knn = 1 only the nearest nodes to the chosen coordinates will be returned. If knn = 2 the two nearest nodes will be returned etc.
#' @param membership Logical. If TRUE the search for nodes is limited to nodes that belong to a road network that is connected either to the from or to nodes (only possible for either from or to). E.g. if you only want to search for from nodes that belong to the same road network as the to nodes, membership is set to FALSE in the search for to nodes and membership = TRUE for the from nodes (in that order).
#'
#'
#' @returns An object (data.frame) with the following columns; from_node/to_node, membership, coords_google_from_node/coords_google_to_node, knn, and ID.
#' @export
#'
#' @examples
#' \dontrun{
#' from <- address_to_coords(zip_code = "0177",
#'                          address = "Akersveien 26")
#' from_node <- coords_to_node(coords = from, direction = "from")
#'
#' to <- address_to_coords(zip_code = "2211",
#'                          address = "Otervegen 23")
#' to_node <- coords_to_node(coords = to, direction = "to")
#' }
#' @encoding UTF-8
#'
#'
coords_to_node <- function(coords,
direction = "from",
ID_col = "ID",
crs_out = 25833,
knn = 1,
membership = F) {
if (direction == "from"){
nodes_start <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$from))
# # OBS
if (membership == T){
nodes_start <- nodes_start %>%
dplyr::filter(membership %in% unique(to_node$membership))
}
coords_start <- nodes_start %>%
sf::st_coordinates()
from_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(from_coord) <- c("X", "Y")
node_index_o <- nabor::knn(data = coords_start,
query = from_coord,
k = knn)
nodes_start <- sf::st_transform(nodes_start, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(from_nodeID = nodeID,
coords_google_from_node = coords_google,
membership_from_node = membership,
knn_from_node = knn) %>%
dplyr::select(-geometry)
start_node <- nodes_start[node_index_o$nn.idx, ]
start_node$knn <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
select(-geometry)
dists <-  data.frame(ID, node_index_o$nn.dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_from") %>%
dplyr::select(-variabel)
start_node <- cbind(start_node, dists) %>%
dplyr::rename()
return(start_node)
}
if (direction == "to"){
nodes_end <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$to))
if (membership == T){
nodes_end <- nodes_end %>%
dplyr::filter(membership %in% unique(from_node$membership))
}
coords_end <- nodes_end %>%
sf::st_coordinates()
to_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(to_coord) <- c("X", "Y")
node_index_d <- nabor::knn(data = coords_end,
query = to_coord,
k = 1)
nodes_end <- sf::st_transform(nodes_end, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(to_nodeID = nodeID,
coords_google_to_node = coords_google) %>%
dplyr::select(-geometry)
end_node <- nodes_end[node_index_d$nn.idx, ]
end_node$knn <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
select(-geometry)
dists <-  data.frame(ID, node_index_d$nn.dists)
# return(dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_to") %>%
dplyr::select(-variabel)
end_node <- cbind(end_node, dists)
return(end_node)
}
}
from_node <- coords_to_node(coords = from, direction = "from")
from_node
#' Connect coordinates to the nearest nodes in the Norwegian road network
#'
#' Function to find the nearest nodes in the Norwegian road network for chosen coordinates.
#'
#' Before the function can be used, the nodes of the road network must be converted to an sf object that is called `nodes`. This can be done with the function `vegnett_to_R`.
#'
#' @param coords An sf object with the coordinates that should be connected to the road network.
#' @param direction Character vector with “from” if the points should be from nodes or “to” if the points should be to nodes.
#' @param ID_col Character vector with the name of the ID column. Default value is set to “ID”.
#' @param crs_out Numeric vector for the chosen coordinate reference system (CRS).
#' @param knn Numeric vector with the chosen number of nodes that should be returned for each of the coordinates. If knn = 1 only the nearest nodes to the chosen coordinates will be returned. If knn = 2 the two nearest nodes will be returned etc.
#' @param membership Logical. If TRUE the search for nodes is limited to nodes that belong to a road network that is connected either to the from or to nodes (only possible for either from or to). E.g. if you only want to search for from nodes that belong to the same road network as the to nodes, membership is set to FALSE in the search for to nodes and membership = TRUE for the from nodes (in that order).
#'
#'
#' @returns An object (data.frame) with the following columns; from_node/to_node, membership, coords_google_from_node/coords_google_to_node, knn, and ID.
#' @export
#'
#' @examples
#' \dontrun{
#' from <- address_to_coords(zip_code = "0177",
#'                          address = "Akersveien 26")
#' from_node <- coords_to_node(coords = from, direction = "from")
#'
#' to <- address_to_coords(zip_code = "2211",
#'                          address = "Otervegen 23")
#' to_node <- coords_to_node(coords = to, direction = "to")
#' }
#' @encoding UTF-8
#'
#'
coords_to_node <- function(coords,
direction = "from",
ID_col = "ID",
crs_out = 25833,
knn = 1,
membership = F) {
if (direction == "from"){
nodes_start <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$from))
# # OBS
if (membership == T){
nodes_start <- nodes_start %>%
dplyr::filter(membership %in% unique(to_node$membership))
}
coords_start <- nodes_start %>%
sf::st_coordinates()
from_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(from_coord) <- c("X", "Y")
node_index_o <- nabor::knn(data = coords_start,
query = from_coord,
k = knn)
nodes_start <- sf::st_transform(nodes_start, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(from_nodeID = nodeID,
coords_google_from_node = coords_google,
membership_from_node = membership,
knn_from_node = knn) %>%
dplyr::select(-geometry)
start_node <- nodes_start[node_index_o$nn.idx, ]
start_node$knn_from_node <- rep(1:knn_from_node, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
select(-geometry)
dists <-  data.frame(ID, node_index_o$nn.dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_from") %>%
dplyr::select(-variabel)
start_node <- cbind(start_node, dists) %>%
dplyr::rename()
return(start_node)
}
if (direction == "to"){
nodes_end <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$to))
if (membership == T){
nodes_end <- nodes_end %>%
dplyr::filter(membership %in% unique(from_node$membership))
}
coords_end <- nodes_end %>%
sf::st_coordinates()
to_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(to_coord) <- c("X", "Y")
node_index_d <- nabor::knn(data = coords_end,
query = to_coord,
k = 1)
nodes_end <- sf::st_transform(nodes_end, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(to_nodeID = nodeID,
coords_google_to_node = coords_google) %>%
dplyr::select(-geometry)
end_node <- nodes_end[node_index_d$nn.idx, ]
end_node$knn <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
select(-geometry)
dists <-  data.frame(ID, node_index_d$nn.dists)
# return(dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_to") %>%
dplyr::select(-variabel)
end_node <- cbind(end_node, dists)
return(end_node)
}
}
from_node <- coords_to_node(coords = from, direction = "from")
#' Connect coordinates to the nearest nodes in the Norwegian road network
#'
#' Function to find the nearest nodes in the Norwegian road network for chosen coordinates.
#'
#' Before the function can be used, the nodes of the road network must be converted to an sf object that is called `nodes`. This can be done with the function `vegnett_to_R`.
#'
#' @param coords An sf object with the coordinates that should be connected to the road network.
#' @param direction Character vector with “from” if the points should be from nodes or “to” if the points should be to nodes.
#' @param ID_col Character vector with the name of the ID column. Default value is set to “ID”.
#' @param crs_out Numeric vector for the chosen coordinate reference system (CRS).
#' @param knn Numeric vector with the chosen number of nodes that should be returned for each of the coordinates. If knn = 1 only the nearest nodes to the chosen coordinates will be returned. If knn = 2 the two nearest nodes will be returned etc.
#' @param membership Logical. If TRUE the search for nodes is limited to nodes that belong to a road network that is connected either to the from or to nodes (only possible for either from or to). E.g. if you only want to search for from nodes that belong to the same road network as the to nodes, membership is set to FALSE in the search for to nodes and membership = TRUE for the from nodes (in that order).
#'
#'
#' @returns An object (data.frame) with the following columns; from_node/to_node, membership, coords_google_from_node/coords_google_to_node, knn, and ID.
#' @export
#'
#' @examples
#' \dontrun{
#' from <- address_to_coords(zip_code = "0177",
#'                          address = "Akersveien 26")
#' from_node <- coords_to_node(coords = from, direction = "from")
#'
#' to <- address_to_coords(zip_code = "2211",
#'                          address = "Otervegen 23")
#' to_node <- coords_to_node(coords = to, direction = "to")
#' }
#' @encoding UTF-8
#'
#'
coords_to_node <- function(coords,
direction = "from",
ID_col = "ID",
crs_out = 25833,
knn = 1,
membership = F) {
if (direction == "from"){
nodes_start <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$from))
# # OBS
if (membership == T){
nodes_start <- nodes_start %>%
dplyr::filter(membership %in% unique(to_node$membership))
}
coords_start <- nodes_start %>%
sf::st_coordinates()
from_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(from_coord) <- c("X", "Y")
node_index_o <- nabor::knn(data = coords_start,
query = from_coord,
k = knn)
nodes_start <- sf::st_transform(nodes_start, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(from_nodeID = nodeID,
coords_google_from_node = coords_google,
membership_from_node = membership) %>%
dplyr::select(-geometry)
start_node <- nodes_start[node_index_o$nn.idx, ]
start_node$knn_from_node <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
select(-geometry)
dists <-  data.frame(ID, node_index_o$nn.dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_from") %>%
dplyr::select(-variabel)
start_node <- cbind(start_node, dists) %>%
dplyr::rename()
return(start_node)
}
if (direction == "to"){
nodes_end <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$to))
if (membership == T){
nodes_end <- nodes_end %>%
dplyr::filter(membership %in% unique(from_node$membership))
}
coords_end <- nodes_end %>%
sf::st_coordinates()
to_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(to_coord) <- c("X", "Y")
node_index_d <- nabor::knn(data = coords_end,
query = to_coord,
k = 1)
nodes_end <- sf::st_transform(nodes_end, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(to_nodeID = nodeID,
coords_google_to_node = coords_google) %>%
dplyr::select(-geometry)
end_node <- nodes_end[node_index_d$nn.idx, ]
end_node$knn <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
select(-geometry)
dists <-  data.frame(ID, node_index_d$nn.dists)
# return(dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_to") %>%
dplyr::select(-variabel)
end_node <- cbind(end_node, dists)
return(end_node)
}
}
from_node <- coords_to_node(coords = from, direction = "from")
from_node
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
# Lager vignette
# usethis::use_vignette("GISSB_vignette")
usethis::use_pkgdown() # OBS: docs legges i .gitignore (må fjernes)
pkgdown::build_site()
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
# Lager vignette
# usethis::use_vignette("GISSB_vignette")
usethis::use_pkgdown() # OBS: docs legges i .gitignore (må fjernes)
pkgdown::build_site()
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
devtools::check()
# Lag pakke
devtools::build()
# Lager vignette
# usethis::use_vignette("GISSB_vignette")
usethis::use_pkgdown() # OBS: docs legges i .gitignore (må fjernes)
pkgdown::build_site()
install.packages("C:/Users/rdn/Documents/Github/GISSB_0.1.0.tar.gz", repos = NULL, type="source")
install.packages("C:/Users/rdn/Documents/Github/GISSB_0.1.0.tar.gz", repos = NULL, type="source")
# Lager vignette
# usethis::use_vignette("GISSB_vignette")
usethis::use_pkgdown() # OBS: docs legges i .gitignore (må fjernes)
pkgdown::build_site()
# OBS: mangler dokumentasjon!
?GISSB::path_leaflet
