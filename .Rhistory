#' }
#' @encoding UTF-8
#'
#'
coords_to_node <- function(coords,
direction = "from",
ID_col = "ID",
crs_out = 25833,
knn = 1,
membership = F) {
if (direction == "from"){
nodes_start <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$from))
# # OBS
if (membership == T){
nodes_start <- nodes_start %>%
dplyr::filter(membership %in% unique(to_node$membership_to_node))
}
coords_start <- nodes_start %>%
sf::st_coordinates()
from_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(from_coord) <- c("X", "Y")
node_index_o <- nabor::knn(data = coords_start,
query = from_coord,
k = knn)
nodes_start <- sf::st_transform(nodes_start, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(from_nodeID = nodeID,
coords_google_from_node = coords_google,
membership_from_node = membership) %>%
dplyr::select(-geometry)
start_node <- nodes_start[node_index_o$nn.idx, ]
start_node$knn_from_node <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
dplyr::select(-geometry)
dists <-  data.frame(ID, node_index_o$nn.dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_from") %>%
dplyr::select(-variabel)
start_node <- cbind(start_node, dists)
return(start_node)
}
if (direction == "to"){
nodes_end <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$to))
if (membership == T){
nodes_end <- nodes_end %>%
dplyr::filter(membership %in% unique(from_node$membership_from_node))
}
coords_end <- nodes_end %>%
sf::st_coordinates()
to_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(to_coord) <- c("X", "Y")
node_index_d <- nabor::knn(data = coords_end,
query = to_coord,
k = 1)
nodes_end <- sf::st_transform(nodes_end, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(to_nodeID = nodeID,
coords_google_to_node = coords_google,
membership_to_node = membership) %>%
dplyr::select(-geometry)
end_node <- nodes_end[node_index_d$nn.idx, ]
end_node$knn_to_node <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
select(-geometry)
dists <-  data.frame(ID, node_index_d$nn.dists)
# return(dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_to") %>%
dplyr::select(-variabel)
end_node <- cbind(end_node, dists)
return(end_node)
}
}
from_node <- coords_to_node(coords = from, direction = "from")
to <- address_to_coords(zip_code = "2211", address = "Otervegen 23")
to_node <- coords_to_node(coords = to, direction = "to")
to <- address_to_coords(zip_code = "2211", address = "Otervegen 23")
to_node <- coords_to_node(coords = to, direction = "to")
#' Connect coordinates to the nearest nodes in the road network
#'
#' `coords_to_node` is a function to find the nearest nodes in the Norwegian road network for chosen coordinates.
#'
#' Before the function can be used, the nodes of the road network must be converted to an sf object that is called `nodes`. This can be done with the function [GISSB::vegnett_to_R()].
#'
#' @param coords An sf object with the coordinates that should be connected to the road network.
#' @param direction Character vector with “from” if the points should be from nodes or “to” if the points should be to nodes.
#' @param ID_col Character vector with the name of the ID column. Default value is set to “ID”.
#' @param crs_out Numeric vector for the chosen coordinate reference system (CRS).
#' @param knn Numeric vector with the chosen number of nodes that should be returned for each of the coordinates. If `knn = 1` only the nearest nodes to the chosen coordinates will be returned. If `knn = 2` the two nearest nodes will be returned etc.
#' @param membership Logical. If TRUE the search for nodes is limited to nodes that belong to a road network that is connected either to the from or to nodes (only possible for either from or to). E.g. if you only want to search for from nodes that belong to the same road network as the to nodes, membership is set to FALSE in the search for to nodes and membership = TRUE for the from nodes (in that order).
#'
#'
#' @returns An object (data.frame) with the following columns; `from_nodeID`/`to_nodeID`, `membership_from_node`/`membership_to_node`, `coords_google_from_node`/`coords_google_to_node`, `knn_from_node`/`knn_to_node`, and `ID`.
#' @export
#'
#' @examples
#' \dontrun{
#' from <- address_to_coords(zip_code = "0177",
#'                          address = "Akersveien 26")
#' from_node <- coords_to_node(coords = from, direction = "from")
#'
#' to <- address_to_coords(zip_code = "2211",
#'                          address = "Otervegen 23")
#' to_node <- coords_to_node(coords = to, direction = "to")
#' }
#' @encoding UTF-8
#'
#'
coords_to_node <- function(coords,
direction = "from",
ID_col = "ID",
crs_out = 25833,
knn = 1,
membership = F) {
if (direction == "from"){
nodes_start <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$from))
# # OBS
if (membership == T){
nodes_start <- nodes_start %>%
dplyr::filter(membership %in% unique(to_node$membership_to_node))
}
coords_start <- nodes_start %>%
sf::st_coordinates()
from_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(from_coord) <- c("X", "Y")
node_index_o <- nabor::knn(data = coords_start,
query = from_coord,
k = knn)
nodes_start <- sf::st_transform(nodes_start, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(from_nodeID = nodeID,
coords_google_from_node = coords_google,
membership_from_node = membership) %>%
dplyr::select(-geometry)
start_node <- nodes_start[node_index_o$nn.idx, ]
start_node$knn_from_node <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
dplyr::select(-geometry)
dists <-  data.frame(ID, node_index_o$nn.dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_from") %>%
dplyr::select(-variabel)
start_node <- cbind(start_node, dists)
return(start_node)
}
if (direction == "to"){
nodes_end <- nodes %>%
dplyr::filter(nodeID %in% unique(edges$to))
if (membership == T){
nodes_end <- nodes_end %>%
dplyr::filter(membership %in% unique(from_node$membership_from_node))
}
coords_end <- nodes_end %>%
sf::st_coordinates()
to_coord <- coords %>%
sf::st_coordinates() %>%
matrix(ncol = 2)
colnames(to_coord) <- c("X", "Y")
node_index_d <- nabor::knn(data = coords_end,
query = to_coord,
k = 1)
nodes_end <- sf::st_transform(nodes_end, crs = 4326) %>%
coords_to_google() %>%
data.frame() %>%
dplyr::rename(to_nodeID = nodeID,
coords_google_to_node = coords_google,
membership_to_node = membership) %>%
dplyr::select(-geometry)
end_node <- nodes_end[node_index_d$nn.idx, ]
end_node$knn_to_node <- rep(1:knn, each=nrow(coords))
# ID <- coords$ID
ID <- coords %>%
dplyr::select(!!as.name(ID_col)) %>%
data.frame() %>%
dplyr::select(-geometry)
dists <-  data.frame(ID, node_index_d$nn.dists)
# return(dists)
dists <- reshape2::melt(dists, id.vars = ID_col,
variable.name = "variabel",
value.name = "dist_coord_node_to") %>%
dplyr::select(-variabel)
end_node <- cbind(end_node, dists)
return(end_node)
}
}
to <- address_to_coords(zip_code = "2211", address = "Otervegen 23")
to_node <- coords_to_node(coords = to, direction = "to")
to_node
from_node
from
from_node
distance_min <- shortest_path_igraph(from_node_ID = unique(from_node$from_nodeID),
to_node_ID = unique(to_node$to_nodeID),
unit = "FT_MINUTES")
#' Shortest path (igraph)
#'
#' `shortest_path_igraph` is a function to calculate the shortest path (either in minutes or meters) between nodes in the Norwegian road network. The function can also return the node link (path) that the shortest path consists of.
#'
#' Before the function can be used, the road network must be converted to a tbl_graph object that is called “graph”. This can be done with the function [GISSB::vegnett_to_R()]).
#'
#' @param from_node_ID Numeric value with the from node ID (if multiple node ID’s are to be used, see the function [GISSB::shortest_path_cppRouting()]).
#' @param to_node_ID Numeric value with the to node ID (if multiple node ID’s are to be used, see the function [GISSB::shortest_path_cppRouting()]).
#' @param unit Character vector with "FT_MINUTES" to calculate the shortest path in minutes or "LENGTH" for the shortest path in meters.
#' @param path Logical. If TRUE the node link with the shortest path is returned.
#'
#' @returns Vector with the shortest path in minutes or meters. If path = TRUE the node link that the shortest path consists of is returned.
#' @export
#'
#' @examples
#' \dontrun{
#' distance_min <- shortest_path_igraph(from_node_ID = 26956,
#'                                to_node_ID = 210373,
#'                                unit = "FT_MINUTES")
#'
#' distance_meter <- shortest_path_igraph(from_node_ID = 26956,
#'                                  to_node_ID = 210373,
#'                                  unit = "LENGTH")
#'
#' path <- shortest_path_igraph(from_node_ID = 26956,
#'                         to_node_ID = 210373,
#'                         unit = "FT_MINUTES",
#'                         path = T)
#'                         }
#' @encoding UTF-8
#'
#'
shortest_path_igraph <- function(from_node_ID,
to_node_ID,
unit = "FT_MINUTES",
path = F) {
path_graph <- igraph::shortest_paths(
graph = graph,
from = from_node_ID,
to = to_node_ID,
output = 'both',
weights = graph %>% tidygraph::activate(edges) %>% dplyr::pull(!!as.name(unit))
)
path_graph_length <- graph %>%
igraph::subgraph.edges(eids = path_graph$epath %>%
unlist()) %>%
tidygraph::as_tbl_graph()
distance <- path_graph_length %>%
tidygraph::activate(edges) %>%
tibble::as_tibble() %>%
dplyr::summarise(length = sum(!!as.name(unit)))
if (path == T) {
return(path_graph)
} else {
return(distance)
}
}
distance_min <- shortest_path_igraph(from_node_ID = unique(from_node$from_nodeID),
to_node_ID = unique(to_node$to_nodeID),
unit = "FT_MINUTES")
distance_min
from <- address_to_coords(zip_code = "0177", address = "Akersveien 26")
from_node <- coords_to_node(coords = from, direction = "from")
to <- address_to_coords(zip_code = "2211", address = "Otervegen 23")
to_node <- coords_to_node(coords = to, direction = "to", membership = TRUE)
distance_min <- shortest_path_igraph(from_node_ID = unique(from_node$from_nodeID),
to_node_ID = unique(to_node$to_nodeID),
unit = "FT_MINUTES")
distance_meter <- shortest_path_igraph(from_node_ID = unique(from_node$from_nodeID),
to_node_ID = unique(to_node$to_nodeID),
unit = "LENGTH")
distance_min
path <- shortest_path_igraph(from_node_ID = unique(from_node$from_nodeID),
to_node_ID = unique(to_node$to_nodeID),
unit = "FT_MINUTES",
path = T)
path_leaflet(path)
distance_min <- shortest_path_cppRouting(unique(from_node$from_nodeID),
unique(to_node$to_nodeID),
unit = "FT_MINUTES")
distance_meter <- shortest_path_cppRouting(unique(from_node$from_nodeID),
unique(to_node$to_nodeID),
unit = "LENGTH")
graph
vegnett_list <- vegnett_to_R(vegnett = vegnett)
vegnett <- vegnett_sampledata
vegnett_list <- vegnett_to_R(vegnett = vegnett_sampledata)
graph <- vegnett_list[[1]]
library(GISSB)
vegnett_list <- vegnett_to_R(vegnett = vegnett_sampledata)
#' Convert the Norwegian road network (NVDB Ruteplan nettverksdatasett) into network graphs in R
#'
#' `vegnett_to_R` is a function to convert the Norwegian road network, downloaded from \href{https://kartkatalog.geonorge.no/metadata/nvdb-ruteplan-nettverksdatasett/8d0f9066-34f9-4423-be12-8e8523089313/}{Geonorge}, to formats that allows for network analysis in R (tbl_graph and cppRouting).
#'
#' @param vegnett The Norwegian road network, downloaded from \href{https://kartkatalog.geonorge.no/metadata/nvdb-ruteplan-nettverksdatasett/8d0f9066-34f9-4423-be12-8e8523089313/}{Geonorge}, as an sf object.
#' @param crs_out Numeric vector with the chosen coordinate reference system (CRS).
#'
#' @returns List containing the following elements:
#'
#' `[1] graph`: the road network structured as a tidy graph (tbl_graph object)
#'
#' `[2] nodes`: the road network's nodes (sf object)
#'
#' `[3] edges`: road network's edges/node links (data.frame)
#'
#' `[4] graph_cppRouting_FT_MINUTES`: the road network structured as a cppRouting graph with the cost of travel in minutes (cppRouting object)
#'
#' `[5] graph_cppRouting_LENGTH`: the road network structured as a cppRouting graph with the cost of travel in meters (cppRouting object)
#' @export
#'
#' @examples
#' vegnett_list <- vegnett_to_R(vegnett = vegnett_sampledata)
#'
#' graph <- vegnett_list[[1]]
#' nodes <- vegnett_list[[2]]
#' edges <- vegnett_list[[3]]
#' graph_cppRouting_FT_MINUTES <- vegnett_list[[4]]
#' graph_cppRouting_LENGTH <- vegnett_list[[5]]
#' @encoding UTF-8
#'
#'
vegnett_to_R <- function(vegnett,
crs_out = 25833) {
suppressWarnings(
vegnett <- vegnett %>%
sf::st_zm(drop = T) %>%
dplyr::rename_all(toupper) %>%
dplyr::rename(LENGTH = SHAPE_LENGTH) %>%
sf::st_cast("LINESTRING")
)
rename_geometry <- function(g, name){
current = attr(g, "sf_column")
names(g)[names(g)==current] = name
sf::st_geometry(g)=name
g
}
vegnett <- rename_geometry(vegnett, "geometry")
sf::st_geometry(vegnett) <- "geometry"
######################
## Data processing ###
######################
# Adding an extra row where the road goes both ways #
# Creating a subset with values where the road goes both ways (B) and specifies direction from-to (FT) and to-from (TF) #
B_FT <- vegnett %>%
dplyr::filter(ONEWAY == "B") %>%
dplyr::mutate(direction = "B_FT")
B_TF <- vegnett %>%
dplyr::filter(ONEWAY == "B") %>%
dplyr::mutate(direction = "B_TF")
# Subset with only FT #
FT <- vegnett %>%
dplyr::filter(ONEWAY == "FT") %>%
dplyr::mutate(direction = "FT")
# Subset with only TF #
TF <- vegnett %>%
dplyr::filter(ONEWAY == "TF") %>%
dplyr::mutate(direction = "TF")
# Binding together all the edges #
edges <- rbind(B_FT, FT, B_TF, TF) %>%
dplyr::mutate(edgeID = c(1:dplyr::n())) %>% # adding new edge ID
dplyr::mutate(FT_MINUTES = dplyr::case_when( # specify correct FT_MINUTES for edges that go TF
direction %in% c("B_TF", "TF") ~ TF_MINUTES, TRUE ~ FT_MINUTES))
# Extracting the nodes from the edges and specifies start and end #
nodes <- edges %>%
sf::st_coordinates() %>%
dplyr::as_tibble() %>%
dplyr::rename(edgeID = L1) %>%
dplyr::group_by(edgeID) %>%
dplyr::slice(c(1, dplyr::n())) %>%
dplyr::ungroup() %>%
dplyr::mutate(start_end = rep(c('start', 'end'), times = dplyr::n()/2))
nodes  <- dplyr::left_join(nodes, edges, by = c("edgeID")) %>%
dplyr::mutate(start_end = dplyr::case_when(
direction %in% c("B_TF", "TF") & start_end == "start" ~ "end",
direction %in% c("B_TF", "TF") & start_end == "end" ~ "start", TRUE ~ start_end)) %>%
dplyr::mutate(xy = paste(.$X, .$Y)) %>% # adding node ID
dplyr::mutate(xy = factor(xy, levels = unique(xy))) %>%
dplyr::group_by(xy) %>%
dplyr::mutate(nodeID = dplyr::cur_group_id()) %>%
dplyr::ungroup() %>%
dplyr::select(-xy, -geometry) #
# Start nodes #
source_nodes <- nodes %>%
dplyr::filter(start_end == 'start') %>%
dplyr::pull(nodeID)
# End nodes #
target_nodes <- nodes %>%
dplyr::filter(start_end == 'end') %>%
dplyr::pull(nodeID)
# Creating edges from source_nodes and target_nodes #
edges <- edges %>%
dplyr::mutate(from = source_nodes, to = target_nodes)
# Extracting distinct nodes with coordinates #
nodes <- nodes %>%
dplyr::distinct(nodeID, .keep_all = TRUE) %>%
dplyr::select(-c(edgeID, start_end)) %>%
sf::st_as_sf(coords = c('X', 'Y')) %>%
sf::st_set_crs(sf::st_crs(edges))
# Creating tbl_graph object of the road network #
graph <- tidygraph::tbl_graph(nodes = nodes, edges = dplyr::as_tibble(edges), directed = T)
# Removing loops in the graph #
graph <- igraph::simplify(graph, remove.loops = T, remove.multiple = F)
graph <- tidygraph::as_tbl_graph(graph)
# Extracting new edges (where loops are removed) #
edges <- graph %>%
tidygraph::activate(edges) %>%
data.frame()
membership <- igraph::components(graph)$membership
membership <- data.frame(membership)
nodes <- nodes %>%
cbind(membership) %>%
dplyr::select(nodeID, geometry, membership) %>%
sf::st_set_crs(crs_out)
################################
## Creating cppRouting graph ###
################################
# FT_MINUTES #
edges_FT_MINUTES <- edges %>%
data.frame() %>%
dplyr::select(from, to, FT_MINUTES) %>%
dplyr::rename(weight = FT_MINUTES) %>%
dplyr::mutate(from = as.character(from),
to = as.character(to))
# LENGTH #
edges_LENGTH <- edges %>%
data.frame() %>%
dplyr::select(from, to, LENGTH) %>%
dplyr::rename(weight = LENGTH) %>%
dplyr::mutate(from = as.character(from),
to = as.character(to))
node_list_coord <- nodes %>%
dplyr::mutate(X = unlist(purrr::map(geometry,1)),
Y = unlist(purrr::map(geometry,2))) %>%
data.frame() %>%
dplyr::select(nodeID, X, Y)
### Creating cppRouting graph ###
graph_cppRouting_FT_MINUTES <- cppRouting::makegraph(edges_FT_MINUTES, directed = T, coords = node_list_coord)
graph_cppRouting_LENGTH <- cppRouting::makegraph(edges_LENGTH, directed = T, coords = node_list_coord)
return(list(graph,
nodes,
edges,
graph_cppRouting_FT_MINUTES,
graph_cppRouting_LENGTH))
}
vegnett_list <- vegnett_to_R(vegnett = vegnett_sampledata)
graph <- vegnett_list[[1]]
nodes <- vegnett_list[[2]]
edges <- vegnett_list[[3]]
graph_cppRouting_FT_MINUTES <- vegnett_list[[4]]
graph_cppRouting_LENGTH <- vegnett_list[[5]]
graph
head(graph)
nodes
edges
graph_cppRouting_FT_MINUTES
graph_cppRouting_LENGTH
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
# Lag pakke (?)
devtools::build()
# Lager vignette
# usethis::use_vignette("GISSB_vignette")
usethis::use_pkgdown() # OBS: docs legges i .gitignore (må fjernes)
pkgdown::build_site()
install.packages("C:/Users/rdn/Documents/Github/GISSB_1.0.tar.gz", repos = NULL, type="source")
install.packages("C:/Users/rdn/Documents/Github/GISSB_1.0.tar.gz", repos = NULL, type="source")
library(GISSB)
vegnett <- vegnett_sampledata
vegnett_list <- vegnett_to_R(vegnett = vegnett_sampledata)
graph <- vegnett_list[[1]]
nodes <- vegnett_list[[2]]
edges <- vegnett_list[[3]]
graph_cppRouting_FT_MINUTES <- vegnett_list[[4]]
graph_cppRouting_LENGTH <- vegnett_list[[5]]
graph
nodes
edges
graph_cppRouting_FT_MINUTES
graph_cppRouting_LENGTH
library(devtools)
library(usethis)
library(roxygen2)
library(testthat)
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
install.packages("C:/Users/rdn/Documents/Github/GISSB_1.0.tar.gz", repos = NULL, type="source")
# rm(list = c("beregne_avstand_cpp"))
devtools::document()
# Lag pakke (?)
devtools::build()
devtools::install_github("statisticsnorway/GISSB",
auth_token = getPass::getPass("PAT: "))
